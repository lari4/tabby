# Tabby Agent Pipelines Documentation

Это полная документация всех пайплайнов и схем работы AI агентов в приложении Tabby. Каждый пайплайн описан с указанием потока данных, используемых промтов и форматов вывода.

---

## 1. Answer/Chat Pipeline - Пайплайн ответов на вопросы

### Назначение
Обработка вопросов пользователя с использованием RAG (Retrieval-Augmented Generation) для предоставления ответов с контекстом из кодовой базы и документации.

### Точка входа
`ee/tabby-webserver/src/service/answer.rs:67` - метод `AnswerService::answer()`

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────┐
│ ВХОД: User Message + Conversation History + Options             │
└────────────────┬────────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Определение необходимости контекста из кодовой базы    │
│ Файл: answer.rs:93-133                                         │
│ Промт: prompt_tools.rs:39-66 (decide_context_prompt)          │
├────────────────────────────────────────────────────────────────┤
│ → LLM анализирует вопрос                                       │
│ → Определяет нужны ли: file_list и/или snippet                │
│ → Возвращает: { snippet: bool, file_list: bool }              │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Сбор контекста из кода (если необходимо)               │
│ Файл: answer.rs:93-133                                         │
├────────────────────────────────────────────────────────────────┤
│ Если file_list == true:                                        │
│   → RetrievalService::collect_file_list()                      │
│   → Максимум 300 файлов                                        │
│                                                                 │
│ Если snippet == true:                                          │
│   → RetrievalService::collect_relevant_code()                  │
│   → Поиск с использованием BM25 + embeddings (RRF scoring)    │
│   → Возвращает релевантные фрагменты кода                     │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Сбор контекста из документации                         │
│ Файл: answer.rs:136-173                                        │
├────────────────────────────────────────────────────────────────┤
│ → RetrievalService::collect_relevant_docs()                    │
│ → Источники: Issues, PRs, Commits, Pages, Web Docs            │
│ → Поиск через Tantivy index + опционально Serper (web)        │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Генерация связанных вопросов (опционально)             │
│ Файл: answer.rs:176-191                                        │
│ Промт: prompt_tools.rs:16-31 (related_questions_prompt)       │
├────────────────────────────────────────────────────────────────┤
│ → LLM генерирует 3 follow-up вопроса                          │
│ → Каждый вопрос максимум 20 слов                              │
│ → Возвращает: JSON массив вопросов                            │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Формирование финального запроса к LLM                  │
│ Файл: answer.rs:194-214                                        │
│ Промт: utils/mod.rs:129-213 (build_user_prompt)               │
├────────────────────────────────────────────────────────────────┤
│ → Добавление системного промта (личность Tabby)               │
│ → Форматирование пользовательского промта с:                  │
│   • Список файлов (если есть)                                  │
│   • Фрагменты кода с цитированием [[citation:x]]             │
│   • Релевантные документы                                      │
│   • Вопрос пользователя                                        │
│   • Инструкции по формату ответа                              │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Потоковая генерация ответа                             │
│ Файл: answer.rs:216-245                                        │
├────────────────────────────────────────────────────────────────┤
│ → chat.chat_stream(request)                                    │
│ → Стриминг ответа по частям (deltas)                          │
│ → Эмиссия событий ThreadRunItem                               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ВЫХОД: Stream of ThreadRunItem Events                          │
├────────────────────────────────────────────────────────────────┤
│ • ThreadAssistantMessageReadingCode                            │
│ • ThreadAssistantMessageAttachmentsCodeFileList                │
│ • ThreadAssistantMessageAttachmentsCode                        │
│ • ThreadAssistantMessageAttachmentsDoc                         │
│ • ThreadRelevantQuestions                                      │
│ • ThreadAssistantMessageContentDelta (streaming content)       │
│ • ThreadAssistantMessageCompleted                              │
└────────────────────────────────────────────────────────────────┘
```

### Используемые промты

1. **Системный промт** (`config.rs:467`)
   - Определяет личность Tabby
   - Отправляется как system message

2. **Промт определения контекста** (`prompt_tools.rs:39-66`)
   - Определяет нужен ли snippet и/или file_list
   - Возвращает JSON: `{"snippet": bool, "file_list": bool}`

3. **Промт построения пользовательского запроса** (`utils/mod.rs:129-213`)
   - Добавляет код-сниппеты с цитированием
   - Форматирует список файлов
   - Включает документы
   - Добавляет инструкции по формату ответа

4. **Промт генерации связанных вопросов** (`prompt_tools.rs:16-31`)
   - Генерирует 3 follow-up вопроса
   - Максимум 20 слов каждый
   - Возвращает JSON массив

### Потоки данных между шагами

```
User Message → Decide Context → { snippet: true, file_list: false }
                ↓
Code Search (BM25+Embeddings) → [CodeHit, CodeHit, ...]
                ↓
Doc Search (Tantivy) → [DocHit, DocHit, ...]
                ↓
Build Prompt → "Here are some relevant code snippets:\n```rust\n..."
                ↓
LLM Stream → "Based on the code..." (deltas)
                ↓
Related Questions → ["How does...", "What is...", "Where can..."]
```

### Форматы данных

**Входные данные:**
```rust
struct AnswerRequest {
    messages: Vec<Message>,
    options: AnswerOptions {
        code_query: Option<CodeQuery>,
        doc_query: Option<DocQuery>,
        generate_relevant_questions: bool,
    }
}
```

**Выходные события (stream):**
```rust
enum ThreadRunItem {
    ThreadAssistantMessageReadingCode,
    ThreadAssistantMessageAttachmentsCodeFileList { file_list: Vec<String> },
    ThreadAssistantMessageAttachmentsCode { hits: Vec<CodeSearchHit> },
    ThreadAssistantMessageAttachmentsDoc { hits: Vec<DocSearchHit> },
    ThreadRelevantQuestions { questions: Vec<String> },
    ThreadAssistantMessageContentDelta { delta: String },
    ThreadAssistantMessageCompleted { id: String },
}
```

### Оптимизации и кэширование

- **Поиск по коду:** Использует RRF (Reciprocal Rank Fusion) для объединения BM25 и embedding scores
- **Лимиты:** Максимум 300 файлов в file_list
- **Цитирование:** Система `[[citation:x]]` для отслеживания источников в ответе
- **Потоковая передача:** Ответ отправляется по мере генерации для улучшения UX

---

## 2. Code Completion Pipeline - Пайплайн автодополнения кода

### Назначение
Генерация автодополнения кода в реальном времени с использованием контекста из текущего файла, недавних изменений, деклараций и поиска по кодовой базе.

### Точки входа

**Клиент:** `clients/tabby-agent/src/codeCompletion/index.ts:478` - `CompletionProvider::generateCompletions()`
**Сервер:** `crates/tabby/src/services/completion.rs`

### Схема потока данных (Client → Server → Client)

```
┌─────────────────────────────────────────────────────────────────┐
│ КЛИЕНТСКАЯ ЧАСТЬ: Подготовка контекста                         │
└─────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Построение базового контекста                          │
│ Файл: index.ts:498-523                                         │
├────────────────────────────────────────────────────────────────┤
│ → Извлечение document, position, notebook cells               │
│ → Создание CompletionContext с prefix/suffix lines            │
│ → Определение языка программирования                          │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Проверка кэша                                           │
│ Файл: index.ts:527-529                                         │
├────────────────────────────────────────────────────────────────┤
│ → Вычисление хэша от контекста                                │
│ → Если есть в кэше → возврат закэшированного результата       │
│ → Иначе → продолжение                                          │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Debouncing (умная задержка)                            │
│ Файл: index.ts:547-565                                         │
├────────────────────────────────────────────────────────────────┤
│ → Определение типа триггера (automatic/manual)                │
│ → Расчет задержки на основе среднего времени ответа           │
│ → Отмена предыдущих запросов                                  │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Сбор дополнительного контекста (параллельно)           │
│ Файл: index.ts:568-634                                         │
│ Таймаут: 500ms для automatic, unlimited для manual             │
├────────────────────────────────────────────────────────────────┤
│ A) Workspace Context:                                          │
│    → Git repo info (url, root)                                 │
│                                                                 │
│ B) Git Context:                                                │
│    → Remote URLs, current branch                               │
│                                                                 │
│ C) Declarations (LSP):                                         │
│    → Определения функций/классов (макс. из config)            │
│    → Через Language Server Protocol                           │
│                                                                 │
│ D) Recent Changes Search:                                      │
│    → BM25 поиск по недавно измененным файлам                  │
│    → Релевантные фрагменты кода                               │
│                                                                 │
│ E) Recently Viewed Files:                                      │
│    → Фрагменты из недавно открытых файлов                     │
│                                                                 │
│ F) Editor Options:                                             │
│    → Indent size, tab size, insert spaces                     │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Построение запроса (Segments)                          │
│ Файл: buildRequest.ts                                          │
├────────────────────────────────────────────────────────────────┤
│ → Формирование объекта Segments:                              │
│   • prefix (обрезан до maxPrefixLines)                        │
│   • suffix (обрезан до maxSuffixLines)                        │
│   • filepath (относительно git root или workspace)            │
│   • git_url                                                    │
│   • declarations                                               │
│   • relevant_snippets_from_changed_files                      │
│   • relevant_snippets_from_recently_opened_files              │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 6: HTTP запрос к серверу                                  │
│ Файл: index.ts:584-660                                         │
├────────────────────────────────────────────────────────────────┤
│ → POST /v1/completions или /v1beta/chat/completions           │
│ → Несколько попыток для manual trigger (maxTries)             │
│ → Варьирование temperature для multiple choices               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ СЕРВЕРНАЯ ЧАСТЬ: Обработка и генерация                         │
└─────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│ ШАГ 7: Обогащение промта контекстом                           │
│ Файл: completion_prompt.rs:32-143                             │
├────────────────────────────────────────────────────────────────┤
│ → Приоритетный сбор сниппетов (макс. 768 chars):              │
│   1. Declarations (из segments)                                │
│   2. Snippets from changed files (из segments)                 │
│   3. Snippets from recently opened files (из segments)         │
│   4. Code search results (минимум 256 chars зарезервировано)  │
│                                                                 │
│ → Code Search (если git_url совпадает с allowed repo):        │
│   • Поиск с BM25 + embeddings                                 │
│   • Merge multi-hit файлов <300 строк в полный файл           │
│                                                                 │
│ → Форматирование сниппетов как комментарии:                   │
│   # Path: file.py                                             │
│   # snippet line 1                                             │
│   # snippet line 2                                             │
│   {original prefix}                                            │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 8: Применение Prompt Template                             │
│ Файл: completion_prompt.rs:32-38                              │
├────────────────────────────────────────────────────────────────┤
│ Если есть prompt_template (зависит от модели):                │
│   → Пример CodeLlama: "<PRE> {prefix} <SUF>{suffix} <MID>"   │
│ Иначе:                                                         │
│   → Просто: "{prefix}"                                         │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 9: LLM Inference                                           │
├────────────────────────────────────────────────────────────────┤
│ → Вызов CodeGeneration или CompletionStream                   │
│ → Возврат raw completion text                                 │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ КЛИЕНТСКАЯ ЧАСТЬ: Постобработка                                │
└─────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│ ШАГ 10: Post-Processing                                        │
│ Файл: index.ts:600-671, postprocess/                          │
├────────────────────────────────────────────────────────────────┤
│ Pre-cache фильтры:                                             │
│ → Базовая фильтрация и форматирование                         │
│                                                                 │
│ Post-cache фильтры:                                            │
│ → Limit scope (удаление кода вне текущей области)             │
│ → Format indentation (корректировка отступов)                 │
│ → Remove duplicates (удаление дубликатов)                     │
│ → Trim space (обрезка пробелов)                               │
│ → Remove linebreaks (удаление лишних переносов)               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ВЫХОД: CompletionResponse                                      │
├────────────────────────────────────────────────────────────────┤
│ {                                                               │
│   id: string,                                                  │
│   choices: [{                                                  │
│     index: number,                                             │
│     text: string  // Completion text                          │
│   }]                                                           │
│ }                                                              │
└────────────────────────────────────────────────────────────────┘
```

### Используемые промты

1. **FIM Prompt Template** (опционально, зависит от модели)
   - Пример для CodeLlama: `<PRE> {prefix} <SUF>{suffix} <MID>`
   - Определяется в конфигурации модели

2. **Контекстные сниппеты** (встраиваются как комментарии)
   - Форматируются в соответствии с синтаксисом комментариев языка
   - Включают путь к файлу и содержимое

### Приоритизация контекста

```
Доступная квота: 768 символов

┌──────────────────────────┐ Высший приоритет
│ 1. Declarations          │ ← Определения функций/классов из LSP
├──────────────────────────┤
│ 2. Changed Files         │ ← Релевантные фрагменты из измененных файлов
├──────────────────────────┤
│ 3. Recently Opened       │ ← Фрагменты из недавно открытых файлов
├──────────────────────────┤
│ 4. Code Search           │ ← Поиск по кодовой базе (мин. 256 chars)
└──────────────────────────┘ Низший приоритет

Если квота исчерпана, последующие источники игнорируются
```

### Потоки данных

```
Document Context → Build Segments → {prefix, suffix, filepath, git_url, ...}
                                              ↓
                          Parallel Context Collection (500ms timeout):
                                    ├─→ LSP Declarations
                                    ├─→ Recent Changes Search
                                    ├─→ Recently Viewed Files
                                    └─→ Git/Workspace Info
                                              ↓
                                   Build Request Payload
                                              ↓
                                    POST /v1/completions
                                              ↓
                          Server: Enrich with Code Search
                                              ↓
                          Server: Format Prompt with Template
                                              ↓
                                      LLM Inference
                                              ↓
                                  Raw Completion Text
                                              ↓
                          Client: Post-processing Filters
                                              ↓
                                    Final Completion
```

### Форматы данных

**Segments (запрос от клиента к серверу):**
```typescript
interface Segments {
  prefix: string;
  suffix?: string;
  filepath?: string;
  git_url?: string;
  declarations?: Declaration[];
  relevant_snippets_from_changed_files?: Snippet[];
  relevant_snippets_from_recently_opened_files?: Snippet[];
}
```

**CompletionResponse (ответ от сервера):**
```typescript
interface CompletionResponse {
  id: string;
  choices: Array<{
    index: number;
    text: string;
  }>;
}
```

### Оптимизации и кэширование

- **Context-Hash Based Cache:** Кэш основан на хэше контекста (prefix, suffix, snippets)
- **Debouncing:** Умная задержка на основе среднего времени ответа
- **Parallel Context Fetch:** Параллельный сбор контекста с таймаутом 500ms
- **Quota Management:** Приоритизация источников контекста с лимитом 768 chars
- **Code Search Merge:** Объединение multi-hit файлов <300 строк в полный файл
- **Post-processing Pipeline:** Многоступенчатая фильтрация для улучшения качества

---

## 3. Page Generation Pipeline - Пайплайн генерации документации

### Назначение
Автоматическая генерация страниц документации на основе кодовой базы и контекста беседы. Включает создание заголовка, структуры разделов и контента.

### Точка входа
`ee/tabby-webserver/src/service/page.rs:135` - метод `PageServiceImpl::create_run()`

### Схема потока данных

```
┌────────────────────────────────────────────────────────────────┐
│ ВХОД: Conversation Thread + Title Prompt + Options             │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Получение начального контекста через Answer Pipeline   │
│ Файл: page.rs:144-207                                          │
├────────────────────────────────────────────────────────────────┤
│ → Вызов AnswerService::answer() с title_prompt                │
│ → Сбор code & doc attachments из кодовой базы                 │
│ → Построение временного сообщения с контентом ассистента      │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Генерация заголовка страницы                           │
│ Файл: page.rs:486-493, 649-679                                │
│ Промт: prompt_tools.rs:3-11 (prompt_page_title)               │
├────────────────────────────────────────────────────────────────┤
│ → LLM генерирует краткий заголовок                            │
│ → Из предоставленного промта или суммаризации беседы          │
│ → Эмит: PageCreated { id, author_id, title }                  │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Генерация заголовков разделов                          │
│ Файл: page.rs:539-562, 996-1030                               │
│ Промт: prompt_tools.rs:52-73 (prompt_page_section_titles)     │
├────────────────────────────────────────────────────────────────┤
│ → LLM генерирует 3 заголовка разделов                         │
│ → Использует существующие секции + thread messages как context│
│ → Эмит: PageSectionsCreated { sections: [{id, title, pos}] }  │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Генерация введения страницы                            │
│ Файл: page.rs:564-587, 785-816                                │
│ Промт: prompt_tools.rs:13-29 (prompt_page_content)            │
├────────────────────────────────────────────────────────────────┤
│ → LLM генерирует вводный параграф                             │
│ → На основе заголовка страницы + заголовков разделов          │
│ → Эмит (streaming):                                            │
│   • PageContentDelta { delta: string }                         │
│   • PageContentCompleted { id }                                │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Для каждого раздела (цикл)                             │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ├──────────────────────────────────────────────┐
                 │                                               │
                 ▼                                               ▼
┌─────────────────────────────────┐  ┌─────────────────────────────────┐
│ ШАГ 5a: Сбор code attachments   │  │ ШАГ 5b: Сбор doc attachments    │
│ Файл: page.rs:876-913           │  │ Файл: page.rs:915-960           │
├─────────────────────────────────┤  ├─────────────────────────────────┤
│ → Code search по source_id      │  │ → Doc search по doc_query       │
│ → Запрос = заголовок раздела    │  │ → Фильтрация self-references    │
│ → Эмит: PageSectionAttachment-  │  │ → Эмит: PageSectionAttachment-  │
│   Code { id, codes: [hit] }     │  │   Doc { id, doc: [hit] }        │
└────────────────┬────────────────┘  └────────────────┬────────────────┘
                 │                                     │
                 └──────────────┬──────────────────────┘
                                │
                                ▼
                 ┌─────────────────────────────────────────┐
                 │ ШАГ 5c: Генерация контента раздела       │
                 │ Файл: page.rs:963-990, 1032-1065         │
                 │ Промт: prompt_tools.rs:75-92             │
                 │      (prompt_page_section_content)       │
                 ├─────────────────────────────────────────┤
                 │ → LLM генерирует параграф с code        │
                 │ → Учитывает page context + attachments  │
                 │ → Эмит (streaming):                      │
                 │   • PageSectionContentDelta { id, delta }│
                 │   • PageSectionContentCompleted { id }   │
                 └────────────────┬────────────────────────┘
                                  │
                 ┌────────────────┘
                 │ (Повтор для следующего раздела)
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Завершение                                              │
│ Файл: page.rs:641-643                                          │
├────────────────────────────────────────────────────────────────┤
│ → Эмит: PageCompleted { id }                                   │
└────────────────────────────────────────────────────────────────┘
```

### Используемые промты

1. **Page Title Prompt** - Генерация краткого заголовка
2. **Page Section Titles Prompt** - Генерация 3 заголовков разделов
3. **Page Content Prompt** - Генерация вводного параграфа
4. **Page Section Content Prompt** - Генерация контента раздела

### Поток событий (Stream)

```
PageCreated
    ↓
PageSectionsCreated (3 sections)
    ↓
PageContentDelta (streaming intro)
PageContentDelta (streaming intro)
...
PageContentCompleted
    ↓
PageSectionAttachmentCode (section 1)
PageSectionAttachmentDoc (section 1)
PageSectionContentDelta (section 1)
...
PageSectionContentCompleted (section 1)
    ↓
PageSectionAttachmentCode (section 2)
PageSectionAttachmentDoc (section 2)
PageSectionContentDelta (section 2)
...
PageSectionContentCompleted (section 2)
    ↓
... (repeat for section 3)
    ↓
PageCompleted
```

### Оптимизации

- **Потоковая генерация:** Контент генерируется и отправляется по мере создания
- **Контекстная релевантность:** Каждый раздел получает свои code/doc attachments
- **Избежание дублирования:** Инструкции не повторять паттерны из предыдущих разделов

---

## 4. Repository Analysis Pipeline - Анализ структуры репозитория

### Назначение
Генерация вопросов для онбординга новых разработчиков на основе структуры файлов и директорий репозитория.

### Точка входа
`ee/tabby-webserver/src/service/repository/mod.rs:77` - метод `RepositoryService::read_repository_related_questions()`

### Схема потока данных

```
┌────────────────────────────────────────────────────────────────┐
│ ВХОД: Repository Source ID                                     │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Поиск репозитория и проверка доступа                   │
│ Файл: repository/mod.rs:90-92                                  │
├────────────────────────────────────────────────────────────────┤
│ → Lookup repository по source_id                               │
│ → Проверка policy access                                       │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Получение списка файлов                                │
│ Файл: repository/mod.rs:94-105                                 │
├────────────────────────────────────────────────────────────────┤
│ → Вызов RepositoryService::list_files() с лимитом 300         │
│ → Использует tabby_git::list_files()                          │
│ → Возвращает: (Vec<FileEntrySearchResult>, truncated: bool)   │
│                                                                 │
│ Формат каждого файла:                                          │
│ • type: "file" | "dir"                                         │
│ • path: String                                                 │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Генерация вопросов                                     │
│ Файл: repository/prompt_tools.rs:27-44                        │
│ Промт: pipeline_related_questions_with_repo_dirs              │
├────────────────────────────────────────────────────────────────┤
│ → Формирование промта с деревом файлов                        │
│ → LLM генерирует 3 вопроса (макс. 10 слов каждый)            │
│ → Кэширование на 30 минут (RELATED_QUESTIONS_CACHE_LIFESPAN) │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ВЫХОД: Vec<String> - Список из 3 вопросов                     │
└────────────────────────────────────────────────────────────────┘
```

### Используемый промт

**Repository Questions Prompt:**
```text
You are a helpful assistant that helps the user to ask related questions
about a codebase "{repository_name}".

Here is codebase directory structure:
Type: dir, Path: src/
Type: file, Path: src/main.rs
Type: dir, Path: tests/
...
Note: The file list has been truncated. There may be more files...

Please generate 3 specific questions to help a new engineer understand
this codebase.

Each question should be concise (max 10 words) and focused.
Return only the questions, one per line.
```

### Дополнительные операции

**File Search** (`search_files` method):
- Использует `tabby_git::search_files()` для pattern matching
- Поддерживает glob patterns
- Возвращает top N результатов с индексами совпадений

**Grep** (`grep` method):
- Использует `tabby_git::grep()` для поиска по содержимому
- Возвращает файлы + строки совпадений с byte offsets

### Кэширование

- **Time-based cache:** Кэш на 30 минут для сгенерированных вопросов
- **Per-repository:** Кэш привязан к source_id репозитория

---

## 5. Client-Side Edit Pipelines - Клиентские пайплайны редактирования

### Назначение
Интеллектуальное редактирование кода в IDE через команды пользователя с использованием LLM для генерации, изменения и форматирования кода.

### 5.1. Inline Edit Pipeline - Редактирование кода

#### Точка входа
`clients/tabby-agent/src/chat/inlineEdit.ts:143` - `ChatEditProvider::provideEdit()`

#### Схема потока данных

```
┌────────────────────────────────────────────────────────────────┐
│ ВХОД: Document + Selection/Position + Command + Context        │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Валидация и определение режима                         │
│ Файл: inlineEdit.ts:143-186                                    │
├────────────────────────────────────────────────────────────────┤
│ → Проверка доступности фичи                                   │
│ → Валидация длины документа (max из config)                   │
│ → Инициализация mutex abort controller                        │
│ → Определение режима: INSERT vs REPLACE                       │
│   • INSERT: курсор без выделения                              │
│   • REPLACE: есть выделенный текст                            │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Выбор промта                                            │
│ Файл: inlineEdit.ts:194-203                                    │
├────────────────────────────────────────────────────────────────┤
│ Проверка preset команд:                                        │
│ • /fix → fix-spelling-and-grammar.md                          │
│ • /doc → generate-docs.md                                      │
│ • Custom preset из config                                      │
│                                                                 │
│ Default промты:                                                │
│ • REPLACE → edit-command-replace.md                           │
│ • INSERT → edit-command-insert.md                             │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Извлечение контекста                                   │
│ Файл: inlineEdit.ts:205-219                                    │
├────────────────────────────────────────────────────────────────┤
│ → Selection text (выделенный текст)                           │
│ → Prefix text (с лимитом maxChars)                            │
│ → Suffix text (с лимитом maxChars)                            │
│ → Балансировка prefix/suffix если документ слишком длинный    │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Загрузка файлового контекста (опционально)             │
│ Файл: inlineEdit.ts:221-246                                    │
├────────────────────────────────────────────────────────────────┤
│ Если params.context указаны:                                  │
│ → Загрузка дополнительных файлов                              │
│ → Max files из config                                          │
│ → Max chars per file из config                                │
│ → Форматирование через templates:                             │
│   • include-file-context-list.md                              │
│   • include-file-context-item.md                              │
│                                                                 │
│ Формат:                                                        │
│ title="path/to/file.rs"                                        │
│ referrer="#file1"                                              │
│ <CONTEXTDOCUMENT>content</CONTEXTDOCUMENT>                    │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Построение финального промта                           │
│ Файл: inlineEdit.ts:248-262                                    │
├────────────────────────────────────────────────────────────────┤
│ Подстановка placeholders:                                      │
│ → {{filepath}} - путь к файлу                                 │
│ → {{documentPrefix}} - код перед курсором/выделением          │
│ → {{document}} - выделенный текст (REPLACE mode)              │
│ → {{documentSuffix}} - код после курсора/выделения            │
│ → {{command}} - команда пользователя                          │
│ → {{languageId}} - язык программирования                      │
│ → {{fileContext}} - дополнительные файлы                      │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Потоковый запрос к LLM                                 │
│ Файл: inlineEdit.ts:264-271                                    │
├────────────────────────────────────────────────────────────────┤
│ → TabbyApiClient::fetchChatStream()                           │
│ → POST /v1beta/chat/completions                               │
│ → Streaming response                                           │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 7: Обработка потока и парсинг XML                         │
│ Файл: inlineEdit.ts:290-301, utils.ts:28-183                  │
├────────────────────────────────────────────────────────────────┤
│ → Парсинг XML тегов:                                          │
│   • <GENERATEDCODE>...</GENERATEDCODE> (обязательно)          │
│   • <COMMENTS>...</COMMENTS> (опционально)                    │
│                                                                 │
│ → Генерация diff preview:                                     │
│   • Вычисление insertions (добавления)                        │
│   • Вычисление deletions (удаления)                           │
│   • Unchanged lines (неизменные строки)                       │
│                                                                 │
│ → Применение workspace edits с маркерами:                     │
│   <<<<<<< tabby-abc123                                         │
│   # Comments (если есть)                                       │
│   . unchanged line                                             │
│   | in-progress line (streaming)                              │
│   + added line                                                 │
│   - removed line                                               │
│   = unchanged line                                             │
│   >>>>>>> tabby-abc123 [markers: accept, discard]             │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 8: Резолюция пользователем                                │
│ Файл: inlineEdit.ts:311-395 (resolveEdit)                     │
├────────────────────────────────────────────────────────────────┤
│ Пользователь выбирает действие:                               │
│ → Accept: Применить изменения (убрать маркеры)                │
│ → Discard: Отменить изменения (вернуть оригинал)              │
│ → Cancel: Прервать операцию                                   │
│                                                                 │
│ → Парсинг маркеров для определения финального кода            │
│ → Применение финального workspace edit                        │
└────────────────────────────────────────────────────────────────┘
```

### 5.2. Commit Message Generation Pipeline

#### Схема

```
Git Diff → Build Prompt → LLM → Parse Response → Commit Message
                         (generate-commit-message.md)
```

**Вход:** Git staged changes diff
**Выход:** `<type>(<scope>): <description>` (Conventional Commits format)

### 5.3. Branch Name Generation Pipeline

#### Схема

```
Git Diff + User Input → Build Prompt → LLM → Parse XML → 3-5 Branch Names
                         (generate-branch-name.md)
```

**Вход:** Git diff + опциональный user input
**Выход:** Список из 3-5 kebab-case имен веток в `<BRANCHNAMES>` тегах

### 5.4. Smart Apply Pipeline

#### Схема (двухступенчатая)

```
┌─────────────────────────────────────────────────────┐
│ ЭТАП 1: Определение позиции вставки                 │
├─────────────────────────────────────────────────────┤
│ Document + Code to Insert                           │
│         ↓                                            │
│ Prompt: provide-smart-apply-line-range.md           │
│         ↓                                            │
│ LLM → <GENERATEDCODE>16-19</GENERATEDCODE>         │
│         ↓                                            │
│ Line Range (startLine-endLine)                      │
└───────────────────┬─────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────┐
│ ЭТАП 2: Интеллектуальная вставка кода              │
├─────────────────────────────────────────────────────┤
│ Document + Code Block + Line Range                  │
│         ↓                                            │
│ Prompt: generate-smart-apply.md                     │
│         ↓                                            │
│ LLM → <GENERATEDCODE>                               │
│       full modified document                         │
│       </GENERATEDCODE>                               │
│         ↓                                            │
│ Complete Modified Document                           │
└─────────────────────────────────────────────────────┘
```

**Особенности:**
- Анализ структуры кода для определения лучшей позиции
- Сохранение отступов и форматирования
- Избежание дублирования кода
- Параллельное размещение, а не вложенность

### Используемые промты для всех edit операций

1. **Edit Command Replace** - Изменение выделенного кода
2. **Edit Command Insert** - Вставка нового кода
3. **Generate Docs** - Добавление документации
4. **Fix Spelling and Grammar** - Исправление текста
5. **Smart Apply** - Интеллектуальная вставка кода
6. **Smart Apply Line Range** - Определение позиции вставки
7. **File Context List/Item** - Форматирование дополнительных файлов
8. **Generate Commit Message** - Генерация commit message
9. **Generate Branch Name** - Генерация имен веток

### Diff Markers Format

```text
<<<<<<< tabby-{id}
# Optional comments explaining changes
. unchanged line before
+ newly added line
- removed line
| line being generated (in-progress during streaming)
= unchanged line after
>>>>>>> tabby-{id} [markers: accept, discard]
```

### Оптимизации

- **Mutex Lock:** Предотвращение одновременных edit операций
- **Abort Controller:** Отмена предыдущих запросов при новых
- **Streaming Display:** Показ прогресса генерации в реальном времени
- **Balanced Context:** Умная балансировка prefix/suffix при длинных документах
- **XML Parsing:** Надежный парсинг с fallback на raw text

---

## Общая сводка по пайплайнам

### Количество пайплайнов: 9

1. **Answer/Chat** - 6 шагов, RAG с потоковой генерацией
2. **Code Completion** - 10 шагов, client-server-client flow
3. **Page Generation** - 6 шагов с циклом по разделам
4. **Repository Analysis** - 3 шага с кэшированием
5. **Inline Edit** - 8 шагов с preview и резолюцией
6. **Commit Message** - 3 шага, прямая генерация
7. **Branch Name** - 3 шага, множественные варианты
8. **Smart Apply Line Range** - 3 шага, определение позиции
9. **Smart Apply** - 3 шага, интеллектуальная вставка

### Общие паттерны

#### 1. RAG (Retrieval-Augmented Generation)
Используется в: Answer, Code Completion, Page Generation
- Поиск через BM25 + embeddings
- RRF (Reciprocal Rank Fusion) для ранжирования
- Система цитирования `[[citation:x]]`

#### 2. Streaming Responses
Используется в: Answer, Page Generation, Inline Edit
- Инкрементальная отправка результатов
- Улучшение perceived performance
- Возможность раннего прерывания

#### 3. Кэширование
- **Time-based:** Repository questions (30 мин)
- **Hash-based:** Code completion (context hash)
- **Config-based:** Model-specific templates

#### 4. Приоритизация контекста
Все пайплайны используют приоритизацию:
- Code Completion: Declarations > Changed > Recent > Search
- Answer: Snippet context > File list context
- Page Generation: Existing sections > Attachments

#### 5. XML-структурирование
Клиентские промты используют XML для:
- **Входные данные:** `<USERDOCUMENT>`, `<USERSELECTION>`, etc.
- **Выходные данные:** `<GENERATEDCODE>`, `<BRANCHNAMES>`, etc.
- Надежный парсинг с fallback

#### 6. Quota Management
Лимиты для предотвращения переполнения:
- Code snippets: 768 chars (completion), 256 chars min для search
- File list: 300 files (answer, repository)
- Questions: 3 items, max 10-20 words each
- Response: 1024 tokens (answer)

#### 7. Параллелизация
- Code Completion: Параллельный сбор контекста (LSP, search, git)
- Page Generation: Параллельный сбор code/doc attachments для разделов
- Таймауты: 500ms для automatic triggers

#### 8. Валидация и Access Control
Все серверные пайплайны:
- Проверка `AccessPolicy`
- Валидация source IDs
- Проверка прав доступа к репозиториям

### Интеграционная диаграмма

```
┌──────────────────────────────────────────────────────────────┐
│                    TABBY ARCHITECTURE                         │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────┐          ┌──────────────────┐          │
│  │  IDE/Editor     │◄────────►│  Tabby Agent     │          │
│  │  (VSCode, etc)  │  LSP/API │  (TypeScript)    │          │
│  └─────────────────┘          └────────┬─────────┘          │
│                                         │ HTTP API            │
│                                         ▼                      │
│                               ┌──────────────────┐           │
│                               │  Tabby Server    │           │
│                               │  (Rust)          │           │
│                               └────────┬─────────┘           │
│                                         │                      │
│                  ┌──────────────────────┼──────────────────┐ │
│                  │                      │                   │ │
│                  ▼                      ▼                   ▼ │
│         ┌─────────────┐       ┌─────────────┐    ┌──────────────┐
│         │ Code Search │       │   LLM       │    │ Git Repos    │
│         │ (BM25 +     │       │ (Inference) │    │ (Indexing)   │
│         │  Embeddings)│       │             │    │              │
│         └─────────────┘       └─────────────┘    └──────────────┘
│                                                               │
│  Data Flow:                                                  │
│  1. User Action → Agent → Context Collection                │
│  2. Agent → Server → RAG Search                             │
│  3. Server → LLM → Generation                               │
│  4. Server → Agent → Streaming Response                     │
│  5. Agent → IDE → User Display                              │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### Ключевые метрики

- **Общее количество промтов:** 22+ уникальных промтов
- **Серверные сервисы:** Answer, Page, Repository, Completion
- **Клиентские сервисы:** Inline Edit, Smart Apply, Commit/Branch Gen
- **Используемые технологии:**
  - Поиск: BM25, Embeddings, RRF, Tantivy
  - Протоколы: HTTP API, LSP, WebSocket (streaming)
  - Кэширование: In-memory, time-based, hash-based
  - Форматы: JSON, XML tags, Markdown, Git diff

---

