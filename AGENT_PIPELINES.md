# Tabby Agent Pipelines Documentation

Это полная документация всех пайплайнов и схем работы AI агентов в приложении Tabby. Каждый пайплайн описан с указанием потока данных, используемых промтов и форматов вывода.

---

## 1. Answer/Chat Pipeline - Пайплайн ответов на вопросы

### Назначение
Обработка вопросов пользователя с использованием RAG (Retrieval-Augmented Generation) для предоставления ответов с контекстом из кодовой базы и документации.

### Точка входа
`ee/tabby-webserver/src/service/answer.rs:67` - метод `AnswerService::answer()`

### Схема потока данных

```
┌─────────────────────────────────────────────────────────────────┐
│ ВХОД: User Message + Conversation History + Options             │
└────────────────┬────────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Определение необходимости контекста из кодовой базы    │
│ Файл: answer.rs:93-133                                         │
│ Промт: prompt_tools.rs:39-66 (decide_context_prompt)          │
├────────────────────────────────────────────────────────────────┤
│ → LLM анализирует вопрос                                       │
│ → Определяет нужны ли: file_list и/или snippet                │
│ → Возвращает: { snippet: bool, file_list: bool }              │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Сбор контекста из кода (если необходимо)               │
│ Файл: answer.rs:93-133                                         │
├────────────────────────────────────────────────────────────────┤
│ Если file_list == true:                                        │
│   → RetrievalService::collect_file_list()                      │
│   → Максимум 300 файлов                                        │
│                                                                 │
│ Если snippet == true:                                          │
│   → RetrievalService::collect_relevant_code()                  │
│   → Поиск с использованием BM25 + embeddings (RRF scoring)    │
│   → Возвращает релевантные фрагменты кода                     │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Сбор контекста из документации                         │
│ Файл: answer.rs:136-173                                        │
├────────────────────────────────────────────────────────────────┤
│ → RetrievalService::collect_relevant_docs()                    │
│ → Источники: Issues, PRs, Commits, Pages, Web Docs            │
│ → Поиск через Tantivy index + опционально Serper (web)        │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Генерация связанных вопросов (опционально)             │
│ Файл: answer.rs:176-191                                        │
│ Промт: prompt_tools.rs:16-31 (related_questions_prompt)       │
├────────────────────────────────────────────────────────────────┤
│ → LLM генерирует 3 follow-up вопроса                          │
│ → Каждый вопрос максимум 20 слов                              │
│ → Возвращает: JSON массив вопросов                            │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Формирование финального запроса к LLM                  │
│ Файл: answer.rs:194-214                                        │
│ Промт: utils/mod.rs:129-213 (build_user_prompt)               │
├────────────────────────────────────────────────────────────────┤
│ → Добавление системного промта (личность Tabby)               │
│ → Форматирование пользовательского промта с:                  │
│   • Список файлов (если есть)                                  │
│   • Фрагменты кода с цитированием [[citation:x]]             │
│   • Релевантные документы                                      │
│   • Вопрос пользователя                                        │
│   • Инструкции по формату ответа                              │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 6: Потоковая генерация ответа                             │
│ Файл: answer.rs:216-245                                        │
├────────────────────────────────────────────────────────────────┤
│ → chat.chat_stream(request)                                    │
│ → Стриминг ответа по частям (deltas)                          │
│ → Эмиссия событий ThreadRunItem                               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ВЫХОД: Stream of ThreadRunItem Events                          │
├────────────────────────────────────────────────────────────────┤
│ • ThreadAssistantMessageReadingCode                            │
│ • ThreadAssistantMessageAttachmentsCodeFileList                │
│ • ThreadAssistantMessageAttachmentsCode                        │
│ • ThreadAssistantMessageAttachmentsDoc                         │
│ • ThreadRelevantQuestions                                      │
│ • ThreadAssistantMessageContentDelta (streaming content)       │
│ • ThreadAssistantMessageCompleted                              │
└────────────────────────────────────────────────────────────────┘
```

### Используемые промты

1. **Системный промт** (`config.rs:467`)
   - Определяет личность Tabby
   - Отправляется как system message

2. **Промт определения контекста** (`prompt_tools.rs:39-66`)
   - Определяет нужен ли snippet и/или file_list
   - Возвращает JSON: `{"snippet": bool, "file_list": bool}`

3. **Промт построения пользовательского запроса** (`utils/mod.rs:129-213`)
   - Добавляет код-сниппеты с цитированием
   - Форматирует список файлов
   - Включает документы
   - Добавляет инструкции по формату ответа

4. **Промт генерации связанных вопросов** (`prompt_tools.rs:16-31`)
   - Генерирует 3 follow-up вопроса
   - Максимум 20 слов каждый
   - Возвращает JSON массив

### Потоки данных между шагами

```
User Message → Decide Context → { snippet: true, file_list: false }
                ↓
Code Search (BM25+Embeddings) → [CodeHit, CodeHit, ...]
                ↓
Doc Search (Tantivy) → [DocHit, DocHit, ...]
                ↓
Build Prompt → "Here are some relevant code snippets:\n```rust\n..."
                ↓
LLM Stream → "Based on the code..." (deltas)
                ↓
Related Questions → ["How does...", "What is...", "Where can..."]
```

### Форматы данных

**Входные данные:**
```rust
struct AnswerRequest {
    messages: Vec<Message>,
    options: AnswerOptions {
        code_query: Option<CodeQuery>,
        doc_query: Option<DocQuery>,
        generate_relevant_questions: bool,
    }
}
```

**Выходные события (stream):**
```rust
enum ThreadRunItem {
    ThreadAssistantMessageReadingCode,
    ThreadAssistantMessageAttachmentsCodeFileList { file_list: Vec<String> },
    ThreadAssistantMessageAttachmentsCode { hits: Vec<CodeSearchHit> },
    ThreadAssistantMessageAttachmentsDoc { hits: Vec<DocSearchHit> },
    ThreadRelevantQuestions { questions: Vec<String> },
    ThreadAssistantMessageContentDelta { delta: String },
    ThreadAssistantMessageCompleted { id: String },
}
```

### Оптимизации и кэширование

- **Поиск по коду:** Использует RRF (Reciprocal Rank Fusion) для объединения BM25 и embedding scores
- **Лимиты:** Максимум 300 файлов в file_list
- **Цитирование:** Система `[[citation:x]]` для отслеживания источников в ответе
- **Потоковая передача:** Ответ отправляется по мере генерации для улучшения UX

---

## 2. Code Completion Pipeline - Пайплайн автодополнения кода

### Назначение
Генерация автодополнения кода в реальном времени с использованием контекста из текущего файла, недавних изменений, деклараций и поиска по кодовой базе.

### Точки входа

**Клиент:** `clients/tabby-agent/src/codeCompletion/index.ts:478` - `CompletionProvider::generateCompletions()`
**Сервер:** `crates/tabby/src/services/completion.rs`

### Схема потока данных (Client → Server → Client)

```
┌─────────────────────────────────────────────────────────────────┐
│ КЛИЕНТСКАЯ ЧАСТЬ: Подготовка контекста                         │
└─────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│ ШАГ 1: Построение базового контекста                          │
│ Файл: index.ts:498-523                                         │
├────────────────────────────────────────────────────────────────┤
│ → Извлечение document, position, notebook cells               │
│ → Создание CompletionContext с prefix/suffix lines            │
│ → Определение языка программирования                          │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 2: Проверка кэша                                           │
│ Файл: index.ts:527-529                                         │
├────────────────────────────────────────────────────────────────┤
│ → Вычисление хэша от контекста                                │
│ → Если есть в кэше → возврат закэшированного результата       │
│ → Иначе → продолжение                                          │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 3: Debouncing (умная задержка)                            │
│ Файл: index.ts:547-565                                         │
├────────────────────────────────────────────────────────────────┤
│ → Определение типа триггера (automatic/manual)                │
│ → Расчет задержки на основе среднего времени ответа           │
│ → Отмена предыдущих запросов                                  │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 4: Сбор дополнительного контекста (параллельно)           │
│ Файл: index.ts:568-634                                         │
│ Таймаут: 500ms для automatic, unlimited для manual             │
├────────────────────────────────────────────────────────────────┤
│ A) Workspace Context:                                          │
│    → Git repo info (url, root)                                 │
│                                                                 │
│ B) Git Context:                                                │
│    → Remote URLs, current branch                               │
│                                                                 │
│ C) Declarations (LSP):                                         │
│    → Определения функций/классов (макс. из config)            │
│    → Через Language Server Protocol                           │
│                                                                 │
│ D) Recent Changes Search:                                      │
│    → BM25 поиск по недавно измененным файлам                  │
│    → Релевантные фрагменты кода                               │
│                                                                 │
│ E) Recently Viewed Files:                                      │
│    → Фрагменты из недавно открытых файлов                     │
│                                                                 │
│ F) Editor Options:                                             │
│    → Indent size, tab size, insert spaces                     │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 5: Построение запроса (Segments)                          │
│ Файл: buildRequest.ts                                          │
├────────────────────────────────────────────────────────────────┤
│ → Формирование объекта Segments:                              │
│   • prefix (обрезан до maxPrefixLines)                        │
│   • suffix (обрезан до maxSuffixLines)                        │
│   • filepath (относительно git root или workspace)            │
│   • git_url                                                    │
│   • declarations                                               │
│   • relevant_snippets_from_changed_files                      │
│   • relevant_snippets_from_recently_opened_files              │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 6: HTTP запрос к серверу                                  │
│ Файл: index.ts:584-660                                         │
├────────────────────────────────────────────────────────────────┤
│ → POST /v1/completions или /v1beta/chat/completions           │
│ → Несколько попыток для manual trigger (maxTries)             │
│ → Варьирование temperature для multiple choices               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ СЕРВЕРНАЯ ЧАСТЬ: Обработка и генерация                         │
└─────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│ ШАГ 7: Обогащение промта контекстом                           │
│ Файл: completion_prompt.rs:32-143                             │
├────────────────────────────────────────────────────────────────┤
│ → Приоритетный сбор сниппетов (макс. 768 chars):              │
│   1. Declarations (из segments)                                │
│   2. Snippets from changed files (из segments)                 │
│   3. Snippets from recently opened files (из segments)         │
│   4. Code search results (минимум 256 chars зарезервировано)  │
│                                                                 │
│ → Code Search (если git_url совпадает с allowed repo):        │
│   • Поиск с BM25 + embeddings                                 │
│   • Merge multi-hit файлов <300 строк в полный файл           │
│                                                                 │
│ → Форматирование сниппетов как комментарии:                   │
│   # Path: file.py                                             │
│   # snippet line 1                                             │
│   # snippet line 2                                             │
│   {original prefix}                                            │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 8: Применение Prompt Template                             │
│ Файл: completion_prompt.rs:32-38                              │
├────────────────────────────────────────────────────────────────┤
│ Если есть prompt_template (зависит от модели):                │
│   → Пример CodeLlama: "<PRE> {prefix} <SUF>{suffix} <MID>"   │
│ Иначе:                                                         │
│   → Просто: "{prefix}"                                         │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ШАГ 9: LLM Inference                                           │
├────────────────────────────────────────────────────────────────┤
│ → Вызов CodeGeneration или CompletionStream                   │
│ → Возврат raw completion text                                 │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────────────┐
│ КЛИЕНТСКАЯ ЧАСТЬ: Постобработка                                │
└─────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────┐
│ ШАГ 10: Post-Processing                                        │
│ Файл: index.ts:600-671, postprocess/                          │
├────────────────────────────────────────────────────────────────┤
│ Pre-cache фильтры:                                             │
│ → Базовая фильтрация и форматирование                         │
│                                                                 │
│ Post-cache фильтры:                                            │
│ → Limit scope (удаление кода вне текущей области)             │
│ → Format indentation (корректировка отступов)                 │
│ → Remove duplicates (удаление дубликатов)                     │
│ → Trim space (обрезка пробелов)                               │
│ → Remove linebreaks (удаление лишних переносов)               │
└────────────────┬───────────────────────────────────────────────┘
                 │
                 ▼
┌────────────────────────────────────────────────────────────────┐
│ ВЫХОД: CompletionResponse                                      │
├────────────────────────────────────────────────────────────────┤
│ {                                                               │
│   id: string,                                                  │
│   choices: [{                                                  │
│     index: number,                                             │
│     text: string  // Completion text                          │
│   }]                                                           │
│ }                                                              │
└────────────────────────────────────────────────────────────────┘
```

### Используемые промты

1. **FIM Prompt Template** (опционально, зависит от модели)
   - Пример для CodeLlama: `<PRE> {prefix} <SUF>{suffix} <MID>`
   - Определяется в конфигурации модели

2. **Контекстные сниппеты** (встраиваются как комментарии)
   - Форматируются в соответствии с синтаксисом комментариев языка
   - Включают путь к файлу и содержимое

### Приоритизация контекста

```
Доступная квота: 768 символов

┌──────────────────────────┐ Высший приоритет
│ 1. Declarations          │ ← Определения функций/классов из LSP
├──────────────────────────┤
│ 2. Changed Files         │ ← Релевантные фрагменты из измененных файлов
├──────────────────────────┤
│ 3. Recently Opened       │ ← Фрагменты из недавно открытых файлов
├──────────────────────────┤
│ 4. Code Search           │ ← Поиск по кодовой базе (мин. 256 chars)
└──────────────────────────┘ Низший приоритет

Если квота исчерпана, последующие источники игнорируются
```

### Потоки данных

```
Document Context → Build Segments → {prefix, suffix, filepath, git_url, ...}
                                              ↓
                          Parallel Context Collection (500ms timeout):
                                    ├─→ LSP Declarations
                                    ├─→ Recent Changes Search
                                    ├─→ Recently Viewed Files
                                    └─→ Git/Workspace Info
                                              ↓
                                   Build Request Payload
                                              ↓
                                    POST /v1/completions
                                              ↓
                          Server: Enrich with Code Search
                                              ↓
                          Server: Format Prompt with Template
                                              ↓
                                      LLM Inference
                                              ↓
                                  Raw Completion Text
                                              ↓
                          Client: Post-processing Filters
                                              ↓
                                    Final Completion
```

### Форматы данных

**Segments (запрос от клиента к серверу):**
```typescript
interface Segments {
  prefix: string;
  suffix?: string;
  filepath?: string;
  git_url?: string;
  declarations?: Declaration[];
  relevant_snippets_from_changed_files?: Snippet[];
  relevant_snippets_from_recently_opened_files?: Snippet[];
}
```

**CompletionResponse (ответ от сервера):**
```typescript
interface CompletionResponse {
  id: string;
  choices: Array<{
    index: number;
    text: string;
  }>;
}
```

### Оптимизации и кэширование

- **Context-Hash Based Cache:** Кэш основан на хэше контекста (prefix, suffix, snippets)
- **Debouncing:** Умная задержка на основе среднего времени ответа
- **Parallel Context Fetch:** Параллельный сбор контекста с таймаутом 500ms
- **Quota Management:** Приоритизация источников контекста с лимитом 768 chars
- **Code Search Merge:** Объединение multi-hit файлов <300 строк в полный файл
- **Post-processing Pipeline:** Многоступенчатая фильтрация для улучшения качества

---

